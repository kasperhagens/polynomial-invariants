# This is a Python-SymPy version of the GNU Octave invariant algorithm presented in the paper: Matrix invariants for program equivalence in LCTRSs
# https://www.cs.ru.nl/~cynthiakop/wpte23.pdf

import sympy as sp
from sympy import sstr
from itertools import product

# ===========================
# invariants(n, d, chi, init)
# ===========================
# Input
# -----
# n: the number of divergence variables
# d: the degree of the polynomial invariants
# chi: the divergence substitution
# init: the initialization vector, which should be of length n

# Output
# ------
# A set of polynomial invariants of degree d

def invariants(n, d, chi, init):
    # ---------------------------------------
    # Generate divergence variables Y1,...,Yn
    # ---------------------------------------
    Y = sp.symbols(f'Y1:{n+1}')  # Y1, Y2, ..., Yn
    # Convert Y into a matrix data structure 
    Y = sp.Matrix(Y)

    # ------------------------------
    # Generate the monomial vector M
    # ------------------------------
    M = []
    for p in range(d + 1):
        # Compute the monomials Y1^j1*...*Yn^jn, where exp = (j1, ..., jn) ranges over 
        # {(j_1, ..., j_n) | sum_{i=1}^n j_i = p}, and store the result in M. 
        for exp in product(range(p + 1), repeat=n):
            if sum(exp) == p:
                # Fix order: apply reversed(-) to make sure that Y1 gets the first exponent (instead of Yn)
                mon = sp.prod(Y[i] ** j_i for i, j_i in enumerate(reversed(exp)))
                M.append(mon)
    M = sp.Matrix(M) 
    # Note: m = number of monomials in the polynomial invariant (of degree d in n variables) 
    m = len(M)

    # ---------------------------
    # Generate divergence vectors 
    # e0,...,em-1
    # ---------------------------
    e = [sp.Matrix(init)]
    # From the input data: e0 = init  
    # By definition, e[i] = chi(e[i-1]) for i = 1,...,m-1
    for i in range(1, m):
        e.append(chi(e[i - 1]))

    # ------------------------------------
    # Generate divergence matrix D:
    # Row i of D equals M evaluated in e[i]
    # ------------------------------------
    D = sp.zeros(m, m)  # preallocate an m x m symbolic matrix

    for i in range(m):
        # Make dictionary: 
        # for every i, want to substitute Y[j] := e[i][j], for all j.
        # This is used below to evaluate M in e[i]
        subs_dict = {Y[j]: e[i][j] for j in range(n)}

        # Row i of D equals M evaluated in e[i]
        for col, mon in enumerate(M):
            # Technical notes: 
            # enumerate(M) equals ((0, M[0]), (1, M[1]), (2, M[2])), ... 
            # subs is a method on SymPy expressions that substitutes variables according to a dictionary
            D[i, col] = mon.subs(subs_dict)


    # ------------------------------------------------
    # Print result together with important information
    # ------------------------------------------------
    print(f"Polynomial degree: d = {d} ")
    print("Initial vector: e0 =",
      [sp.simplify(e) for e in init])
    print("Divergence variables:", ", ".join(str(y) for y in Y))
    print(f"Divergence substitution: chi({', '.join(str(y) for y in Y)}) =")
    chiY = chi(Y)
    sp.pprint(chiY)
    print("Monomial vector: M = [", ", ".join(sstr(m).replace("**", "^") for m in M), "]")
    print("\nDivergence matrix: D = ")
    sp.pprint(D)

    # -------------------------
    # Compute kernel and invariants
    # -------------------------
    print("\nker(D) is generated by the following vectors:\n")
    B = D.nullspace()
    for b in B:
        sp.pprint(b)
        print()

    print("This corresponds to the following polynomial invariants:\n")
    Invariants = []
    for b in B:
        inv = sum(b[i] * M[i] for i in range(m))
        eq_str = sp.pretty(sp.expand(inv)) + " = 0" 
        Invariants.append(sp.expand(inv)) 
        print(eq_str)


    return Invariants


# =====================================================
# Calling the invariant function with the desired input
# =====================================================

# ------------------------
# Divergence substitution
# ------------------------
# Note: we always want to to input chi using 1-starting-indexing-notation (so that it corresponds to V_div = {Y1,..., Yn} and we will not get confused). 
# Unfortunately, Python uses 0-starting-indexing. Therefore we define a function index_zero_shift to convert back to 0-starting-indexing. 
def chi(Y):
    return sp.Matrix([
        Y[1] - 1,
        Y[2] + Y[1], 
        Y[3] + Y[1]
    ])

# Convert a 1-starting-indexing substitution to a 0-starting-indexing substitution. 
def index_zero_shift(chi_1based):
    def chi_0based(Y0):
        # Y0[0] = Y1, Y0[1] = Y2, etc.
        # Create 1-based list for the user-defined chi
        Y1based = [None] + list(Y0)  # Y1based[1] = Y1
        # Call the user's 1-based chi
        result_1based = chi_1based(Y1based)
        # Convert back to 0-based for Python
        return sp.Matrix(result_1based)
    return chi_0based


if __name__ == "__main__":
# ------------------------
# Initialization variables
# ------------------------
    x = sp.symbols('x')
   
# -------------- 
# Initial vector 
# --------------
    e0 = sp.Matrix([x-1, x, 0])

# ------------------------------
# Number of divergence variables
# ------------------------------
    n = 3

# -----------------
# Polynomial degree
# -----------------
    d = 1
    
# ----------------------------------------------------
# Calling the invariants function on the desired input
# ----------------------------------------------------
    Invariants = invariants(n, d, index_zero_shift(chi), e0)
